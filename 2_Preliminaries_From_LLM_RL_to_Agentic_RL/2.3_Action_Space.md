# 2.3 Action Space

Agentic RL fundamentally expands beyond traditional text-only generation by splitting actions into free-form communication (A_text) and structured tool operations (A_action), often delimited with special tokens. This hybrid action space enables agents to both communicate naturally and manipulate their environment through tool calls, creating a unified learning framework for language and action.

## Key Takeaways
- **Hybrid Actions**: Text communication + structured tool calls in unified action space
- **Special Tokens**: Delimiters separate text from tool operations for parser reliability
- **Unified Training**: Single policy learns both communication and tool use simultaneously
- **Action Validation**: Security constraints ensure safe tool execution and bounded operations

## Prerequisites Check

```bash
# Verify parsing libraries
python -c "import re, json, ast; print('Text parsing tools ready')"
python -c "import inspect; print('Function introspection available')"

# Conceptual check
echo "Do you understand function calls and JSON structure?"
echo "Are you familiar with text parsing and regular expressions?"
```

## Hands-On: Action Space Comparison

### PBRFT: Text-Only Actions
```python
import re
from typing import Union, Dict, Any

class PBRFTActionSpace:
    """Simple text-only action space for preference-based fine-tuning"""
    
    def __init__(self, max_tokens: int = 512):
        self.action_type = "text_only"
        self.max_tokens = max_tokens
        
    def sample_action(self) -> str:
        """PBRFT actions are just text responses"""
        return "This is a helpful response to your question."
    
    def validate_action(self, action: str) -> bool:
        """Simple validation - just check length and basic safety"""
        if len(action) > self.max_tokens:
            return False
        
        # Basic content filtering
        forbidden_patterns = ['<script>', 'eval(', 'exec(']
        return not any(pattern in action.lower() for pattern in forbidden_patterns)
    
    def parse_action(self, action: str) -> Dict:
        """Parse text-only action (trivial)"""
        return {
            'type': 'text_response',
            'content': action,
            'tokens': len(action.split()),
            'validation': self.validate_action(action)
        }

# Demo PBRFT action space
pbrft_actions = PBRFTActionSpace()

example_action = "I can help you with that question. Here's what I think..."
parsed = pbrft_actions.parse_action(example_action)
print("PBRFT Action Parse:", parsed)
print("Action space size: Unlimited text (constrained by token limit)")
```

### Agentic RL: Hybrid Action Space  
```python
import json
import re
from typing import Dict, List, Union, Optional
from dataclasses import dataclass

@dataclass
class ToolCall:
    """Structured tool invocation"""
    tool_name: str
    arguments: Dict[str, Any]
    call_id: Optional[str] = None

class AgenticActionSpace:
    """Hybrid action space: text + structured tool calls"""
    
    def __init__(self, available_tools: List[str]):
        self.available_tools = available_tools
        self.action_delimiter = "<|action|>"
        self.tool_delimiter = "<|tool|>"
        self.end_delimiter = "<|end|>"
        
        # Define tool schemas for validation
        self.tool_schemas = {
            'calculator': {
                'required_args': ['expression'],
                'optional_args': [],
                'arg_types': {'expression': str}
            },
            'web_search': {
                'required_args': ['query'],
                'optional_args': ['max_results'],
                'arg_types': {'query': str, 'max_results': int}
            },
            'memory_store': {
                'required_args': ['operation', 'data'],
                'optional_args': [],
                'arg_types': {'operation': str, 'data': str}
            }
        }
    
    def create_action(self, text: str = "", tool_calls: List[ToolCall] = None) -> str:
        """Create properly formatted hybrid action"""
        action_parts = []
        
        # Add text component
        if text:
            action_parts.append(text)
        
        # Add tool calls with delimiters
        if tool_calls:
            for tool_call in tool_calls:
                tool_action = f"{self.tool_delimiter}{tool_call.tool_name}:{json.dumps(tool_call.arguments)}{self.end_delimiter}"
                action_parts.append(tool_action)
        
        return " ".join(action_parts)
    
    def parse_action(self, raw_action: str) -> Dict:
        """Parse hybrid action into text and tool components"""
        result = {
            'text_content': '',
            'tool_calls': [],
            'validation_errors': []
        }
        
        # Extract tool calls using regex
        tool_pattern = f"{re.escape(self.tool_delimiter)}(.*?){re.escape(self.end_delimiter)}"
        tool_matches = re.findall(tool_pattern, raw_action)
        
        # Remove tool calls from text to get pure text content
        text_content = raw_action
        for match in re.finditer(tool_pattern, raw_action):
            text_content = text_content.replace(match.group(0), "")
        result['text_content'] = text_content.strip()
        
        # Parse each tool call
        for tool_match in tool_matches:
            try:
                if ':' in tool_match:
                    tool_name, args_json = tool_match.split(':', 1)
                    arguments = json.loads(args_json)
                    
                    # Validate tool call
                    validation_result = self.validate_tool_call(tool_name, arguments)
                    if validation_result['valid']:
                        result['tool_calls'].append(ToolCall(tool_name, arguments))
                    else:
                        result['validation_errors'].extend(validation_result['errors'])
                        
            except (json.JSONDecodeError, ValueError) as e:
                result['validation_errors'].append(f"Tool parsing error: {str(e)}")
        
        return result
    
    def validate_tool_call(self, tool_name: str, arguments: Dict) -> Dict:
        """Validate tool call against schema"""
        if tool_name not in self.available_tools:
            return {'valid': False, 'errors': [f"Tool '{tool_name}' not available"]}
        
        if tool_name not in self.tool_schemas:
            return {'valid': False, 'errors': [f"No schema for tool '{tool_name}'"]}
        
        schema = self.tool_schemas[tool_name]
        errors = []
        
        # Check required arguments
        for req_arg in schema['required_args']:
            if req_arg not in arguments:
                errors.append(f"Missing required argument '{req_arg}' for tool '{tool_name}'")
        
        # Check argument types
        for arg_name, arg_value in arguments.items():
            if arg_name in schema['arg_types']:
                expected_type = schema['arg_types'][arg_name]
                if not isinstance(arg_value, expected_type):
                    errors.append(f"Argument '{arg_name}' must be {expected_type.__name__}")
        
        return {'valid': len(errors) == 0, 'errors': errors}
    
    def sample_actions(self) -> List[str]:
        """Generate example hybrid actions"""
        return [
            # Text only
            "I need to solve this step by step.",
            
            # Tool only  
            f"{self.tool_delimiter}calculator:{json.dumps({'expression': '2+2'})}{self.end_delimiter}",
            
            # Hybrid (text + tool)
            f"Let me calculate this for you. {self.tool_delimiter}calculator:{json.dumps({'expression': '15*24'})}{self.end_delimiter} The result is above.",
            
            # Multiple tools
            f"I'll search for information {self.tool_delimiter}web_search:{json.dumps({'query': 'Python tutorials'})}{self.end_delimiter} and save it {self.tool_delimiter}memory_store:{json.dumps({'operation': 'store', 'data': 'tutorial_links'})}{self.end_delimiter}"
        ]

# Demo Agentic action space
agentic_actions = AgenticActionSpace(['calculator', 'web_search', 'memory_store'])

print("=== Sample Agentic Actions ===")
for i, action in enumerate(agentic_actions.sample_actions()):
    print(f"\nAction {i+1}: {action}")
    parsed = agentic_actions.parse_action(action)
    print(f"  Text: '{parsed['text_content']}'")
    print(f"  Tool calls: {len(parsed['tool_calls'])}")
    for tool_call in parsed['tool_calls']:
        print(f"    - {tool_call.tool_name}: {tool_call.arguments}")
    if parsed['validation_errors']:
        print(f"  Validation errors: {parsed['validation_errors']}")
```

## Action Space Architecture Design

### Action Space Size Comparison
```python
def compare_action_spaces():
    """Quantitative comparison of action space sizes"""
    
    # PBRFT: Vocabulary-based text space
    vocab_size = 50000
    max_tokens = 512
    pbrft_space_size = vocab_size ** max_tokens  # Exponentially large
    
    print(f"PBRFT Action Space:")
    print(f"  Type: Text only")
    print(f"  Size: {vocab_size}^{max_tokens} (practically infinite)")
    print(f"  Structure: Unstructured text generation")
    
    # Agentic RL: Text + structured tools
    num_tools = 10
    avg_tool_params = 3
    param_value_options = 100
    
    tool_combinations = (num_tools * (param_value_options ** avg_tool_params))
    agentic_space_size = pbrft_space_size + tool_combinations
    
    print(f"\nAgentic RL Action Space:")
    print(f"  Type: Hybrid (text + tools)")
    print(f"  Text component: {vocab_size}^{max_tokens}")
    print(f"  Tool component: ~{tool_combinations:,} combinations")
    print(f"  Structure: Parsed, validated, executable")
    print(f"  Key difference: Structured executable actions")

compare_action_spaces()
```

### Action Parsing Pipeline
```python
class ActionParsingPipeline:
    """Production-ready action parsing with error handling"""
    
    def __init__(self):
        self.parsing_steps = [
            'tokenize_delimiters',
            'extract_text_components', 
            'extract_tool_components',
            'validate_syntax',
            'validate_semantics',
            'sanitize_inputs'
        ]
    
    def parse_with_pipeline(self, raw_action: str) -> Dict:
        """Multi-stage parsing with detailed error tracking"""
        result = {
            'original': raw_action,
            'parsed': {},
            'pipeline_status': {},
            'errors': [],
            'warnings': []
        }
        
        try:
            # Step 1: Tokenize delimiters
            tokens = self.tokenize_delimiters(raw_action)
            result['pipeline_status']['tokenize_delimiters'] = 'success'
            
            # Step 2: Extract text components
            text_parts = self.extract_text_components(tokens)
            result['parsed']['text'] = ' '.join(text_parts)
            result['pipeline_status']['extract_text_components'] = 'success'
            
            # Step 3: Extract tool components
            tool_calls = self.extract_tool_components(tokens)
            result['parsed']['tools'] = tool_calls
            result['pipeline_status']['extract_tool_components'] = 'success'
            
            # Step 4: Validate syntax
            syntax_valid, syntax_errors = self.validate_syntax(result['parsed'])
            result['pipeline_status']['validate_syntax'] = 'success' if syntax_valid else 'failed'
            result['errors'].extend(syntax_errors)
            
            # Step 5: Validate semantics  
            semantic_valid, semantic_errors = self.validate_semantics(result['parsed'])
            result['pipeline_status']['validate_semantics'] = 'success' if semantic_valid else 'failed'
            result['errors'].extend(semantic_errors)
            
            # Step 6: Sanitize inputs
            result['parsed'] = self.sanitize_inputs(result['parsed'])
            result['pipeline_status']['sanitize_inputs'] = 'success'
            
        except Exception as e:
            result['errors'].append(f"Pipeline error: {str(e)}")
            
        result['overall_status'] = 'success' if not result['errors'] else 'failed'
        return result
    
    def tokenize_delimiters(self, text: str) -> List[str]:
        """Split text on action delimiters"""
        delimiters = ['<|tool|>', '<|end|>', '<|action|>']
        # Simple tokenization - in production, use more robust parser
        tokens = [text]  # Placeholder implementation
        return tokens
    
    def extract_text_components(self, tokens: List[str]) -> List[str]:
        """Extract pure text parts"""
        return ["extracted text"]  # Placeholder
    
    def extract_tool_components(self, tokens: List[str]) -> List[Dict]:
        """Extract and parse tool calls"""
        return [{"tool": "placeholder", "args": {}}]  # Placeholder
    
    def validate_syntax(self, parsed: Dict) -> tuple:
        """Check syntax validity"""
        return True, []  # Placeholder
    
    def validate_semantics(self, parsed: Dict) -> tuple:
        """Check semantic validity"""  
        return True, []  # Placeholder
    
    def sanitize_inputs(self, parsed: Dict) -> Dict:
        """Remove dangerous inputs"""
        return parsed  # Placeholder - implement input sanitization

# Demo parsing pipeline
pipeline = ActionParsingPipeline()
test_action = "Let me help <|tool|>calculator:{'expression': '2+2'}<|end|> you with that."
result = pipeline.parse_with_pipeline(test_action)
print("Pipeline result:", json.dumps(result, indent=2))
```

## Security and Validation Patterns

### Safe Tool Execution
```python
class SafeActionExecutor:
    """Secure execution of hybrid actions with sandboxing"""
    
    def __init__(self):
        self.allowed_tools = {
            'calculator': self.safe_calculator,
            'web_search': self.safe_web_search,
            'memory_store': self.safe_memory_store
        }
        self.execution_limits = {
            'max_execution_time': 5.0,  # seconds
            'max_memory_usage': 100 * 1024 * 1024,  # 100MB
            'max_api_calls_per_minute': 60
        }
    
    def execute_action(self, parsed_action: Dict) -> Dict:
        """Execute hybrid action with safety constraints"""
        results = {
            'text_output': parsed_action.get('text', ''),
            'tool_results': [],
            'execution_status': 'success',
            'security_violations': []
        }
        
        # Execute tool calls with safety checks
        for tool_call in parsed_action.get('tools', []):
            try:
                tool_result = self.execute_tool_safely(tool_call)
                results['tool_results'].append(tool_result)
            except SecurityError as e:
                results['security_violations'].append(str(e))
                results['execution_status'] = 'security_violation'
            except Exception as e:
                results['tool_results'].append({
                    'tool': tool_call.get('tool', 'unknown'),
                    'error': str(e),
                    'status': 'failed'
                })
        
        return results
    
    def execute_tool_safely(self, tool_call: Dict) -> Dict:
        """Execute single tool call with security sandbox"""
        tool_name = tool_call.get('tool')
        
        if tool_name not in self.allowed_tools:
            raise SecurityError(f"Tool {tool_name} not in allowlist")
        
        # Input sanitization
        sanitized_args = self.sanitize_tool_args(tool_call.get('args', {}))
        
        # Execute with timeout and resource limits
        import signal
        import time
        
        start_time = time.time()
        
        def timeout_handler(signum, frame):
            raise TimeoutError("Tool execution timeout")
        
        signal.signal(signal.SIGALRM, timeout_handler)
        signal.alarm(int(self.execution_limits['max_execution_time']))
        
        try:
            tool_function = self.allowed_tools[tool_name]
            result = tool_function(sanitized_args)
            execution_time = time.time() - start_time
            
            return {
                'tool': tool_name,
                'result': result,
                'execution_time': execution_time,
                'status': 'success'
            }
        finally:
            signal.alarm(0)  # Cancel alarm
    
    def sanitize_tool_args(self, args: Dict) -> Dict:
        """Sanitize tool arguments for safety"""
        sanitized = {}
        
        for key, value in args.items():
            # Remove potentially dangerous characters
            if isinstance(value, str):
                # Basic sanitization - remove script tags, eval calls, etc.
                dangerous_patterns = ['<script', 'javascript:', 'eval(', 'exec(']
                safe_value = value
                for pattern in dangerous_patterns:
                    safe_value = safe_value.replace(pattern, '')
                sanitized[key] = safe_value
            else:
                sanitized[key] = value
                
        return sanitized
    
    def safe_calculator(self, args: Dict) -> str:
        """Safe math expression evaluation"""
        expression = args.get('expression', '')
        
        # Whitelist approach - only allow safe math
        import re
        if not re.match(r'^[0-9+\-*/(). ]+$', expression):
            raise SecurityError("Calculator: Invalid characters in expression")
        
        try:
            # Use eval with restricted globals for safety
            safe_globals = {
                '__builtins__': {},
                'abs': abs, 'max': max, 'min': min, 'round': round
            }
            result = eval(expression, safe_globals, {})
            return str(result)
        except:
            raise ValueError("Calculator: Invalid mathematical expression")
    
    def safe_web_search(self, args: Dict) -> str:
        """Safe web search (placeholder)"""
        query = args.get('query', '')
        # In production: implement rate limiting, query validation, etc.
        return f"Search results for: {query}"
    
    def safe_memory_store(self, args: Dict) -> str:
        """Safe memory operations"""
        operation = args.get('operation', '')
        data = args.get('data', '')
        
        if operation not in ['store', 'retrieve', 'delete']:
            raise SecurityError("Memory: Invalid operation")
        
        return f"Memory {operation}: {data}"

class SecurityError(Exception):
    pass

# Demo safe execution
executor = SafeActionExecutor()
test_parsed_action = {
    'text': 'Here is the calculation:',
    'tools': [
        {'tool': 'calculator', 'args': {'expression': '2 + 2 * 3'}},
        {'tool': 'memory_store', 'args': {'operation': 'store', 'data': 'calculation_result'}}
    ]
}

execution_result = executor.execute_action(test_parsed_action)
print("Execution result:", json.dumps(execution_result, indent=2))
```

## ASCII Diagrams: Action Space Evolution

```
PBRFT Action Space:
┌─────────────────────────────────────────┐
│              Text Only                  │
│  "Response to user query..."            │
│                                         │
│  No structure, no tools, no validation │
└─────────────────────────────────────────┘

Agentic RL Action Space:
┌─────────────────┬───────────────────────┐
│   Text Content  │    Tool Operations    │
├─────────────────┼───────────────────────┤
│ "Let me help    │ <|tool|>calculator:   │
│  you with this  │ {"expr": "2+2"}       │
│  calculation."  │ <|end|>              │
└─────────────────┴───────────────────────┘
         │                    │
         ▼                    ▼
┌─────────────────┬───────────────────────┐
│  Communication  │   Environment        │
│  with humans    │   manipulation       │
└─────────────────┴───────────────────────┘

Action Parsing Flow:
Raw Action String
        │
        ▼
┌─────────────────┐
│ Delimiter Split │
└─────────────────┘
        │
        ▼
┌─────────────────┬───────────────────┐
│  Text Extract   │  Tool Extract     │
└─────────────────┴───────────────────┘
        │                    │
        ▼                    ▼
┌─────────────────┬───────────────────┐
│ Content Ready   │ JSON Parse +      │
│ for Generation  │ Validate Schema   │
└─────────────────┴───────────────────┘
        │                    │
        ▼                    ▼
┌─────────────────┬───────────────────┐
│ Direct Output   │ Safe Execution    │
└─────────────────┴───────────────────┘
```

## Training Considerations

### Policy Learning with Hybrid Actions
```python
def hybrid_action_policy_training():
    """Conceptual framework for training policies on hybrid actions"""
    
    training_considerations = {
        'action_representation': {
            'challenge': 'Discrete tools + continuous text',
            'solution': 'Hierarchical action selection',
            'implementation': 'First choose action type, then parameters'
        },
        'credit_assignment': {
            'challenge': 'Which component (text/tool) drove reward?',
            'solution': 'Component-level reward attribution',
            'implementation': 'Separate reward models for text quality vs tool effectiveness'
        },
        'exploration': {
            'challenge': 'Explore tool space vs text space efficiently',
            'solution': 'Structured exploration with tool budgets',
            'implementation': 'Epsilon-greedy for tools, sampling for text'
        },
        'safety_constraints': {
            'challenge': 'Prevent harmful tool usage during training',
            'solution': 'Safe exploration with tool sandbox',
            'implementation': 'Constrained policy optimization with safety rewards'
        }
    }
    
    for aspect, details in training_considerations.items():
        print(f"\n{aspect.upper()}:")
        print(f"  Challenge: {details['challenge']}")
        print(f"  Solution: {details['solution']}")
        print(f"  Implementation: {details['implementation']}")

hybrid_action_policy_training()
```

## Key Differences Summary

| Aspect | PBRFT Actions | Agentic RL Actions |
|--------|---------------|---------------------|
| **Structure** | Unstructured text | Parsed text + tool calls |
| **Validation** | Content filtering only | Syntax + semantic validation |
| **Execution** | Generate and done | Generate + execute tools |
| **Training** | Text generation loss | Multi-component reward |
| **Safety** | Content moderation | Sandboxed tool execution |
| **Complexity** | Linear in tokens | Exponential in tool combinations |
| **Capabilities** | Communication only | Communication + action |

## Practical Exercises

```python
# Exercise 1: Design action format
def exercise_action_format():
    """Design delimiter format for your domain-specific tools"""
    # Your implementation here
    pass

# Exercise 2: Implement tool validation  
def exercise_tool_validation():
    """Create validation schema for custom tool set"""
    # Your implementation here
    pass

# Exercise 3: Build action parser
def exercise_action_parser():
    """Build robust parser with error handling"""
    # Your implementation here
    pass
```

## Resources

- **Survey Reference**: [Section 2.3, arXiv:2509.02547](https://arxiv.org/abs/2509.02547)
- **Tool Integration**: [OpenAI Function Calling Guide](https://platform.openai.com/docs/guides/function-calling)
- **Action Spaces**: [Gymnasium Action Space Documentation](https://gymnasium.farama.org/api/spaces/)
- **Security**: [OWASP Input Validation Guidelines](https://owasp.org/www-project-web-security-testing-guide/)

## Next Steps

- **[2.4 Transition Dynamics](2.4_Transition_Dynamics.md)**: Environment evolution and action effects
- **Practice**: Implement hybrid action parsing for your specific domain
- **Deep Dive**: Study function calling implementations in production LLM systems

---

*Hybrid action spaces are the foundation of agentic behavior - enabling agents to communicate and act simultaneously within a unified learning framework.*
